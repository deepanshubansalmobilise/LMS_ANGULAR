{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, take, Observable, animationFrameScheduler, of, expand, takeWhile, takeUntil, finalize } from 'rxjs';\n\n/**\r\n * https://github.com/gre/bezier-easing\r\n * BezierEasing - use bezier curve for transition easing function\r\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\r\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nconst NEWTON_ITERATIONS = 4;\nconst NEWTON_MIN_SLOPE = 0.001;\nconst SUBDIVISION_PRECISION = 0.0000001;\nconst SUBDIVISION_MAX_ITERATIONS = 10;\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nconst float32ArraySupported = typeof Float32Array === 'function';\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\nfunction C(aA1) {\n  return 3.0 * aA1;\n}\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    let currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    let currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nfunction LinearEasing(x) {\n  return x;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n  // Precompute samples table\n  let sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    let lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    // Interpolate to provide an initial guess for t\n    let dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    let guessForT = intervalStart + dist * kSampleStepSize;\n    let initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return function BezierEasing(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n;\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\n\n// @dynamic\nlet SmoothScrollManager = /*#__PURE__*/(() => {\n  class SmoothScrollManager {\n    get _w() {\n      return this._document.defaultView;\n    }\n    /**\r\n     * Timing method\r\n     */\n    get _now() {\n      return this._w.performance && this._w.performance.now ? this._w.performance.now.bind(this._w.performance) : Date.now;\n    }\n    constructor(_document, _platform, customDefaultOptions) {\n      this._document = _document;\n      this._platform = _platform;\n      // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\n      // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n      // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n      // it cancels the ongoing scroll and starts a new one\n      this._onGoingScrolls = new Map();\n      this._defaultOptions = {\n        duration: 468,\n        easing: {\n          x1: 0.42,\n          y1: 0,\n          x2: 0.58,\n          y2: 1\n        },\n        ...customDefaultOptions\n      };\n    }\n    /**\r\n     * changes scroll position inside an element\r\n     */\n    _scrollElement(el, x, y) {\n      el.scrollLeft = x;\n      el.scrollTop = y;\n    }\n    /**\r\n     * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n     */\n    _getElement(el, parent) {\n      if (typeof el === 'string') {\n        return (parent || this._document).querySelector(el);\n      }\n      return coerceElement(el);\n    }\n    /**\r\n     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n     */\n    _initSmoothScroll(el) {\n      if (this._onGoingScrolls.has(el)) {\n        this._onGoingScrolls.get(el).next();\n      }\n      return this._onGoingScrolls.set(el, new Subject()).get(el);\n    }\n    /**\r\n     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n     */\n    _isFinished(context, destroyed, resolve) {\n      if (context.currentX !== context.x || context.currentY !== context.y) {\n        return true;\n      }\n      destroyed.next();\n      resolve();\n      return false;\n    }\n    /**\r\n     * Terminates an ongoing smooth scroll\r\n     */\n    _interrupted(el, destroyed) {\n      return merge(fromEvent(el, 'wheel', {\n        passive: true,\n        capture: true\n      }), fromEvent(el, 'touchmove', {\n        passive: true,\n        capture: true\n      }), destroyed).pipe(take(1));\n    }\n    /**\r\n     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n     */\n    _destroy(el, destroyed) {\n      destroyed.complete();\n      this._onGoingScrolls.delete(el);\n    }\n    /**\r\n     * A function called recursively that, given a context, steps through scrolling\r\n     */\n    _step(context) {\n      return new Observable(subscriber => {\n        let elapsed = (this._now() - context.startTime) / context.duration;\n        // avoid elapsed times higher than one\n        elapsed = elapsed > 1 ? 1 : elapsed;\n        // apply easing to elapsed time\n        const value = context.easing(elapsed);\n        context.currentX = context.startX + (context.x - context.startX) * value;\n        context.currentY = context.startY + (context.y - context.startY) * value;\n        this._scrollElement(context.scrollable, context.currentX, context.currentY);\n        // Proceed to the step\n        animationFrameScheduler.schedule(() => subscriber.next(context));\n      });\n    }\n    _applyScrollToOptions(el, options) {\n      if (!options.duration) {\n        this._scrollElement(el, options.left, options.top);\n        return Promise.resolve();\n      }\n      // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n      const destroyed = this._initSmoothScroll(el);\n      const context = {\n        scrollable: el,\n        startTime: this._now(),\n        startX: el.scrollLeft,\n        startY: el.scrollTop,\n        x: options.left == null ? el.scrollLeft : ~~options.left,\n        y: options.top == null ? el.scrollTop : ~~options.top,\n        duration: options.duration,\n        easing: bezier(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\n      };\n      return new Promise(resolve => {\n        // Scroll each step recursively\n        of(null).pipe(expand(() => this._step(context).pipe(takeWhile(currContext => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\n      });\n    }\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param scrollable element\r\n     * @param customOptions specified the offsets to scroll to.\r\n     */\n    scrollTo(scrollable, customOptions) {\n      if (isPlatformBrowser(this._platform)) {\n        const el = this._getElement(scrollable);\n        const isRtl = getComputedStyle(el).direction === 'rtl';\n        const rtlScrollAxisType = getRtlScrollAxisType();\n        const options = {\n          ...this._defaultOptions,\n          ...customOptions,\n          ...{\n            // Rewrite start & end offsets as right or left offsets.\n            left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,\n            right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right\n          }\n        };\n        // Rewrite the bottom offset as a top offset.\n        if (options.bottom != null) {\n          options.top = el.scrollHeight - el.clientHeight - options.bottom;\n        }\n        // Rewrite the right offset as a left offset.\n        if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {\n          if (options.left != null) {\n            options.right = el.scrollWidth - el.clientWidth - options.left;\n          }\n          if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {\n            options.left = options.right;\n          } else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {\n            options.left = options.right ? -options.right : options.right;\n          }\n        } else {\n          if (options.right != null) {\n            options.left = el.scrollWidth - el.clientWidth - options.right;\n          }\n        }\n        return this._applyScrollToOptions(el, options);\n      }\n      return Promise.resolve();\n    }\n    /**\r\n     * Scroll to element by reference or selector\r\n     */\n    scrollToElement(scrollable, target, customOptions = {}) {\n      const scrollableEl = this._getElement(scrollable);\n      const targetEl = this._getElement(target, scrollableEl);\n      const options = {\n        ...customOptions,\n        ...{\n          left: targetEl.offsetLeft + (customOptions.left || 0),\n          top: targetEl.offsetTop + (customOptions.top || 0)\n        }\n      };\n      return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\n    }\n    static #_ = this.ɵfac = function SmoothScrollManager_Factory(t) {\n      return new (t || SmoothScrollManager)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8));\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SmoothScrollManager,\n      factory: SmoothScrollManager.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return SmoothScrollManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SmoothScroll = /*#__PURE__*/(() => {\n  class SmoothScroll {\n    constructor(element, smoothScroll) {\n      this.element = element;\n      this.smoothScroll = smoothScroll;\n    }\n    scrollTo(options) {\n      return this.smoothScroll.scrollTo(this.element, options);\n    }\n    scrollToElement(target, options) {\n      return this.smoothScroll.scrollToElement(this.element, target, options);\n    }\n    static #_ = this.ɵfac = function SmoothScroll_Factory(t) {\n      return new (t || SmoothScroll)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SmoothScrollManager));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: SmoothScroll,\n      selectors: [[\"\", \"smoothScroll\", \"\"], [\"\", \"smooth-scroll\", \"\"]],\n      exportAs: [\"smoothScroll\"],\n      standalone: true\n    });\n  }\n  return SmoothScroll;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager };\n//# sourceMappingURL=ngx-scrollbar-smooth-scroll.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}